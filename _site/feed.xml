<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Soo</title>
    <description>My Blog
</description>
    <link>http://simonjisu.github.io/</link>
    <atom:link href="http://simonjisu.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 02 Sep 2017 18:02:45 +0900</pubDate>
    <lastBuildDate>Sat, 02 Sep 2017 18:02:45 +0900</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>algorithm study</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;&lt;strong&gt;알고리즘 공부&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;Hello Coding 그림으로 개념을 이해하는 알고리즘&amp;gt;&lt;/strong&gt; 책을 요약 정리한 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-1--&quot;&gt;Chapter 1. 알고리즘의 소개&lt;/h2&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;simple-search&quot;&gt;단순탐색 simple search&lt;/h4&gt;
&lt;p&gt;단순히 순서대로 추측을 하는 것&lt;/p&gt;

&lt;h4 id=&quot;binary-search&quot;&gt;이진탐색 binary search&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color: #e87d7d&quot;&gt;정렬된&lt;/span&gt; 원소 리스트를 입력으로 받고, 리스트에 원하는 원소가 있으면 그 원소의 위치를 반환, 아니면 null 반환&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;running-time---big-o-notation&quot;&gt;running time 그리고 빅오 표기법(Big O notation)&lt;/h4&gt;
&lt;p&gt;알고리즘의 시간은 어떻게 증가하는가로 측정함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;단순 탐색: &lt;span style=&quot;color: #7d7ee8&quot;&gt;선형 시간(linear time)&lt;/span&gt; 만큼 걸림, $O(n)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이진 탐색: &lt;span style=&quot;color: #7d7ee8&quot;&gt;로그 시간(logarithmic time)&lt;/span&gt; 만큼 걸림, $O(\log_{2}{n})$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;빅오 표기법(Big O notation)&lt;/strong&gt;: 연산 횟수를 나타냄&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;많이 사용하는 빅오(빠른순)&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명 / 예시&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(1)$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(\log{n})$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;이진 탐색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(n)$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;단순 탐색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(n*\log{n})$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;퀵 정렬&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(n^2)$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;선택 정렬&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;$O(n!)$&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;외판원 문제&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;chapter-2--&quot;&gt;Chapter 2. 선택 정렬&lt;/h2&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;section-1&quot;&gt;배열과 연결 리스트&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;리스트&lt;/strong&gt;: 원소를 메모리 아무 곳에다 저장해두고, 각 원소에는 목록의 다음 원소에 대한 주소가 저장되어있음, 특정 원소의 위치를 알려면 앞단의 원소의 위치를 알아야함, 그러나 메모리 공간을 예약 요청해서 저장할 필요가 없음&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;배열&lt;/strong&gt;: 원소들을 메모리에 차례대로 저장함, 특정 원소의 위치를 알기 쉬움 대신 필요한 만큼 미리 일정한 메모리 공간을 요청함, 즉 원소를 추가할 일이 없으면 쓸데 없이 낭비하거나, 추가할 목록이 더 많이 커져 새로 다시 메모리 공간을 요청해야하는 단점이 있음.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;배열&lt;/strong&gt;과 &lt;strong&gt;리스트&lt;/strong&gt;에서 읽기와 쓰기 연산을 하는 데 걸리는 시간:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;배열&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;리스트&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;읽기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(1)$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;삽입&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(n)$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;삭제&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(n)$&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;$O(1)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;자료에 접근하는 방식:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;임의 접근(random access): 임이의 원소에 접근 가능, ex) 배열&lt;/li&gt;
  &lt;li&gt;순차 접근(sequential access): 원소를 첫 번째 부터 하나씩 읽는 것, ex) 연결리스트&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;선택 정렬&lt;/h4&gt;
&lt;p&gt;리스트에에서 모든 항목을 살펴보고 최대값을 찾아서 새로운 리스트에 정렬&lt;/p&gt;

&lt;p&gt;걸리는 시간: $O(n^2)$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;왜 $O(n^2)$ 시간인가?&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;매번 실행할 때마다 점검횟수는 $n-1, n-2, \cdots , 2, 1$ 로 줄어들고, 평균적으로 $n/2$ 만큼 점검한다. 따라서 실제 시간은 평균적으로 $O(n \times 1/2 \times n)$ 인데, 빅오 표기법에서는 상수항은 무시하기 때문에 $O(n \times n)$이 되는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;chapter-3--recursion&quot;&gt;Chapter 3. 재귀 Recursion&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-3&quot;&gt;재귀&lt;/h3&gt;
&lt;p&gt;함수가 자기 자신을 호출하는 것&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본 단계(base case): 함수가 자기 자신을 다시 호출하지 않는 경우, 즉 무한 반복으로 빠져들지 않게 하는 부분&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재귀 단계(recursive case): 함수가 자기 자신을 호출하는 부분&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def countdown(i):
    print i
    if i &amp;lt;= 1:  # 기본 단계
        return
    else:  # 재귀 단계
        countdown(i-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;section-4&quot;&gt;스택&lt;/h3&gt;
&lt;p&gt;아래와 같은 자료구조를 &lt;strong&gt;스택&lt;/strong&gt;이라고 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;푸시(push): 맨 위에 새로운 항목 삽입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;팝(pop): 맨 위에 항목을 읽기&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;호출 스택(call stack)&lt;/strong&gt;: 여러 개의 함수를 호출하면서 함수에 사용되는 변수를 저장하는 스택을 호출 스택이라함&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fact(x):
    if x == 1:
        return 1
    else:
        return x * fact(x-1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;호출 할때 마치 레고블럭을 쌓고 떼듯이 호출함,&lt;/p&gt;

&lt;p&gt;예를 들어, factorial 함수를 들자면&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;진행 순서&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;함수&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;스택(제일 앞에 것이 최근 스택)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;fact(3)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fact(3) 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;if x == 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;False&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;else:&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return x * fact(x-1)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fact(2) 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(2)안의 x = 2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;if x == 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;False&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;else:&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return x * fact(x-1)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;fact(1) 호출&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(1)안의 x = 1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(2)안의 x = 2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;if x == 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;True&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;아직 함수 호출이 끝난건 아니다. 이제 스택에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(1)안의 x=1&lt;/code&gt;를 pop하면 된다. 즉, 반환해야하는 첫 번째 호출인 것이다. 1을 반환&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(1)안의 x = 1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(2)안의 x = 2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return x * fact(x-1)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2 * fact(1) 반환하기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(2)안의 x = 2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;return x * fact(x-1)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3 * fact(2) 반환하기&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fact(3)안의 x = 3&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;단점: 모든 정보를 저장해두어야 하기 때문에 메모리를 많이 소비한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Aug 2017 15:43:39 +0900</pubDate>
        <link>http://simonjisu.github.io/algorithm/2017/08/27/algorithm-study.html</link>
        <guid isPermaLink="true">http://simonjisu.github.io/algorithm/2017/08/27/algorithm-study.html</guid>
        
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>박스앤위스커-박장시님 강연 후기</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;&lt;strong&gt;박스앤위스커 - 박장시님 강연 후기&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;section-1&quot;&gt;주제: 데이터 사이언스에 대한 몇 가지 실제 사례 소개&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-2&quot;&gt;사례들&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1. 문제: 데이터로 무엇을 분석해야하는지 모르는 경우&lt;/h4&gt;
&lt;p&gt;데이터는 많은데, 분석을 어떻게 시작하는 모르는 경우, 우선 평소에 궁금한 것이 무엇인지 알아보기&lt;/p&gt;

&lt;p&gt;streaming data의 검정: A/B test(시간 변수를 통제하기 위함)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;온라인에서의 t-test, large-scale hypothesis testing시 effect size도 고려할 것(p-value가 얼만큼 변했는지)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2. 문제: 인터넷 쇼핑몰에서 어떤 상품 배치가 최적?&lt;/h4&gt;
&lt;p&gt;MD vs 기계의 상품 배치 대결&lt;/p&gt;

&lt;p&gt;웹에서의 ‘땅값’ 개념 도입&lt;/p&gt;

&lt;p&gt;A/B test&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소규모 실험을 우선시 해서, 성과를 보여준 다음에 계속 확대하는 방향으로 가라&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mab-&quot;&gt;3. 문제: MAB 테스트엔진&lt;/h4&gt;
&lt;p&gt;A/B test의 단점:&lt;/p&gt;

&lt;p&gt;1) 테스트가 끝나기 전까지(결과를 얻기전까지) 몇 초간 손해를 볼 수가 있음(기회비용)&lt;/p&gt;

&lt;p&gt;2) exploration vs exploitation&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Discovering new possibilities, conducting research, varying product lines, risk taking, innovation all fall under the realm of exploration. On the other hand, exploitation involves the refinement of current procedures: efficiency, production, execution, and so forth.&lt;/p&gt;

  &lt;p&gt;출처: http://www.indigosim.com/tutorials/exploration/t1s1.htm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3) 항상 변하는 세상: 언제나 옳은 진리는 없음, 상황에 맞춰서 정답도 변하는 세상&lt;/p&gt;

&lt;p&gt;MAB: Multi-armed bandit - &lt;a href=&quot;https://en.wikipedia.org/wiki/Multi-armed_bandit&quot;&gt;개념링크&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점: 다양한 테스트가 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;4. 문제: 전시장 데이터 시각화&lt;/h4&gt;
&lt;p&gt;비콘 data(거리만 나타남)의 처리: 비콘 로그를 이용한 이동범위 추정&lt;/p&gt;

&lt;p&gt;데이터의 편향 가능성: 관심있는 사람만 참가하기 때문에 보편적이지 않을 수도?&lt;/p&gt;

&lt;p&gt;데이터 이상치(outlier)의 처리: 분석후, 현장 전문가 모셔서 이상치를 검증하고 제거&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Force-Directed graph&lt;/li&gt;
  &lt;li&gt;color scheme: 히트맵 그릴시 https://colorbrewer2.org 참고할것&lt;/li&gt;
  &lt;li&gt;numpy for grid: 큰 지도 데이터 경우, 지도를 하나의 큰 matrix로 볼 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;5. 문제: 탱시 운행 정보 시각화&lt;/h4&gt;
&lt;p&gt;택시 미터기 데이터 처리: 미터기를 안누르는 경우도 있고해서 빈 데이터가 가끔 씩 존재했음(택시를 탔는 기록이었는데 다음 데이터에도 다시 타는 기록이 남은 경우), 이때 Finite-state machine 설계를 해서 부족한 데이터를 깔끔하게 보충함(택시를 탔으면 다음에는 무조건 내려야하는 것).&lt;/p&gt;

&lt;h4 id=&quot;eda-----&quot;&gt;6. 문제: 스킬 트리 분석, EDA - 탐색적 자료분석의 중요성&lt;/h4&gt;
&lt;p&gt;특별한 과정은 없음, 우선 데이터의 분포를 그려보는 것이 중요, 그래서 이 데이터를 어떻게 처리할 지 고민할 것&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ggplot&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;7. 문제: 던전 이탈률 분석&lt;/h4&gt;
&lt;p&gt;회귀분석, 의사결정나무를 쓰는 이유는 사람들이 이해하기 쉽기 때문이다. 퍼포먼스는 약간 떨어지지만, 사람들을 설득하는데 도움이 됨. 우선 적용하는게 좋음&lt;/p&gt;

&lt;p&gt;Validation을 어떻게 할지 처음부터 같이 고민할 것.&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;8. 다차원큐브탐색&lt;/h4&gt;
&lt;p&gt;파이콘 2017 세션 강의 참고하기!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;section-9&quot;&gt;느낀점&lt;/h3&gt;
&lt;p&gt;강연이 좋았던게 다양한 사례를 통해서 어떻게 데이터를 접근할지 알려주고, 실제 고객들에게(혹은 다른 사람들에게) 설득하는 방법을 터득할 수가 있었음.&lt;/p&gt;

&lt;p&gt;그리고 항상 프로젝트를 작게 시작하는 법도 배움, 조금씩 해서 성공하면 확장하는 방식으로 사고해야겠음.&lt;/p&gt;

&lt;p&gt;“부산으로 가는데, 모든 신호등이 한번에 초록불로 변할 수는 없는 법” 이말도 인상 깊었다.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Aug 2017 13:34:35 +0900</pubDate>
        <link>http://simonjisu.github.io/datascience/2017/08/18/EB-B0-95-EC-8A-A4-EC-95-A4-EC-9C-84-EC-8A-A4-EC-BB-A4-EB-B0-95-EC-9E-A5-EC-8B-9C-EB-8B-98-EA-B0-95-EC-97-B0-ED-9B-84-EA-B8-B0.html</link>
        <guid isPermaLink="true">http://simonjisu.github.io/datascience/2017/08/18/EB-B0-95-EC-8A-A4-EC-95-A4-EC-9C-84-EC-8A-A4-EC-BB-A4-EB-B0-95-EC-9E-A5-EC-8B-9C-EB-8B-98-EA-B0-95-EC-97-B0-ED-9B-84-EA-B8-B0.html</guid>
        
        
        <category>DataScience</category>
        
      </item>
    
      <item>
        <title>pycon2017</title>
        <description>&lt;h1 id=&quot;pycon-2017-&quot;&gt;&lt;strong&gt;PYCON 2017 후기&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;section&quot;&gt;8월 12일&lt;/h2&gt;

&lt;h3 id=&quot;nlp&quot;&gt;노가다 없는 텍스트 분석을 위한 한국어 NLP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;발표자: 김현중님&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;느낀점:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;제일 처음 들었던 발표기도 했지만, 이번 발표에서 제일 감명깊게 들은 발표, “어떻게 이런 방식으로 생각했지?”라는 생각을 계속함.&lt;/p&gt;

      &lt;p&gt;soynlp라는 패키지로 소스를 공개해주셨으니 앞으로 내가하는 프로젝트에도 아이디어를 적용할 생각이다.&lt;/p&gt;

      &lt;p&gt;이런 컨퍼런스를 많이 참가해서 다른 사람의 아이디어에서 영감을 많이 받을 수도 있다는 생각을 했음.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python-nltk-tensorflow---&quot;&gt;전지양의 꿈을 꾸는 안드로이드: Python과 NLTK, TensorFlow를 이용한 챗봇 감정모형구현&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;발표자: 신정규님&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;느낀점:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;챗봇 팀프로젝트 처음 시작했을 때, 이분의 작년 파이콘강연을 보고 챗봇의 기본적인 구상을 참고했었다. “역시 챗봇은 쉬운게 아니구나”라면서 말이다…&lt;/p&gt;

      &lt;p&gt;다른 곳에서도 이런 생각이 들었지만, 준비하신 내용에 비해 발표시간이 너무 짧았던 것 안타까웠음…코드도 공개하신다고 했으니까 나중에 참고해서 공부하기로 함.&lt;/p&gt;

      &lt;p&gt;감정, 생각 혹은 문장의 이해를 해야하는 부분에서는 Word2vec을 많이 써야된다는 것도 생각하게 됨.&lt;/p&gt;

      &lt;p&gt;또한, 챗봇의 제일 문제점은 사람같지 않다는 점(물론 챗봇이 원래 사람은 아니다만…), 이용자 입장에서 답답하게 느끼지 않게 대화를 이어나갈수 있게하는게 최대의 과제같음.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;8월 13일&lt;/h2&gt;

&lt;h3 id=&quot;python-tensorflow--&quot;&gt;구름이 하늘의 일이라면: Python과 TensorFlow를 이용한 기상예측&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;발표자: 윤상웅님&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;느낀점:&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;데이터 분석할때의 과정과 방향성을 어떻게 잡아야할지 잘 이야기해주셨음.&lt;/p&gt;

      &lt;p&gt;“문제만들기 $\rightarrow$ 모형만들기 $\rightarrow$ 시스템만들기” 라는 순서로 정의하며, 제일 중요한 부분이 “문제를 어떻게 정의 할 것인가”다.&lt;/p&gt;

      &lt;p&gt;물론 도메인 지식이 많이 필요하지만, 공통적인 부분도 있다고 생각했다. 주로, 데이터의 입력/출력, 문제의 유형(supervised/unsupervised), 데이터의 표현 등이었다.&lt;/p&gt;

      &lt;p&gt;결국 우리가 머신러닝을 쓰는 것도 어떤 문제를 해결하려고 하는 것이기 때문에, 문제에 대한 질문을 잘 하고, 문제의 본질을 해석하는 것이 우선순위 같다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;기업 인사담당자들과의 토크&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;느낀점:
    &lt;blockquote&gt;
      &lt;p&gt;중간에 시간이 떠가지고 발표 듣는 대신, wanted에서 마련한 몇개 기업 인사담당자들과의 토크시간에 참석했는데, 생각보다 현업에 계신 분들의 이야기를 많이 들어서 좋았다.&lt;/p&gt;

      &lt;p&gt;업계는 이제 데이터 사이언스 분야의 직업경계선이 차츰 나눠진 듯 하다. 데이터 분석가, 데이터 사이언티스트, 데이터 엔지니어, 세분류로 나눠졌고, 더 이상 머신러닝 패키지를 잘 사용한다고 해서 데이터 사이언티스트가 아니라(요즘은 누구나 시간을 들이면 사용해서 간단한 분석정돈 할 수 있다고 한다.), 어떻게 머신러닝관련 이론을 더 효율적으로 구현을 하는지가 데이터 사이언티스트의 임무라고 생각한다.&lt;/p&gt;

      &lt;p&gt;그리고 기업을 지원할 때, 자신의 무기를 잘 가져야하고(물론 이건 공통된 의견이긴 하지만), 자신이 지원한 분야가 무엇인지 정확히 파악해야한다. 아무튼 알찼던 시간이었다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;공통&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;느낀점:
    &lt;blockquote&gt;
      &lt;p&gt;이번 파이콘에서는 Django에 관련된 발표가 유난히 많았었던것 같다. 아무래도 장고공부도 해야할 것 같다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 14 Aug 2017 19:22:36 +0900</pubDate>
        <link>http://simonjisu.github.io/datascience/2017/08/14/PYCON2017.html</link>
        <guid isPermaLink="true">http://simonjisu.github.io/datascience/2017/08/14/PYCON2017.html</guid>
        
        
        <category>DataScience</category>
        
      </item>
    
      <item>
        <title>End-to-End Memory Network 논문 요약 및 정리</title>
        <description>&lt;h1 id=&quot;end-to-end-memory-network----&quot;&gt;&lt;strong&gt;End-to-End Memory Network 논문 요약 및 정리&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;a-single-layer&quot;&gt;A. Single layer&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/E2EMN.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;input&quot;&gt;Input&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;n 개의 단어가 포함된 한 &lt;strong&gt;문장 sentence i&lt;/strong&gt; 는 $x_i = [x_{i1}, x_{i2}, \cdots, x_{in}]$ 로 표현 할 수 있으며, 하나의 &lt;strong&gt;단어&lt;/strong&gt;는 BoW(Bag-of-Words)방식으로 인코딩 하여 vector로 바꿔준다. 이렇게 구성된 여러 문장들의 집합을 Context ${x_i}$라고 한다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{ij} = [0, 0, \cdots, 1 , \cdots, 0, 0]\quad for\ j^{th}\ words\ in\ sentence\ i&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;t 개의 단어가 포함된 질문 question q도 마찬가지로 BoW방식으로 인코딩해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;sentence $x_1$ = Mary journeyed to the den. 을 예제로 들면,&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{i1} = mary = [1, 0, \cdots, 0, 0]&lt;/script&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{i2} = journeyed = [0, 1, \cdots, 0, 0]&lt;/script&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{i3} = to = [0, \cdots, 1, \cdots, 0, 0]&lt;/script&gt;

  &lt;p&gt;이런식으로 인코딩이 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주의: Mary혹은 mary와 같이 같은 단어를 두 번 세는 것을 피하기 위해서, 모든 단어는 소문자로 바꿔준다.&lt;/p&gt;

&lt;h3 id=&quot;input-memory&quot;&gt;Input Memory&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;하나의 문장 $x_i$ 각각의 단어에 Embedding matrix $A$를 곱하여 각각의 단어를 Embedding Vectors로 변환하고 이를 모두 더하여 메모리 벡터(Memory Vector) $m_i$를 구한다. 이렇게 구성된 여러개의 메모리 벡터 $m_i$들 중 일부를 사용하게 된다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;m_i = \sum_{j}^{n} Ax_{ij} = Ax_{i1} + Ax_{i2} + \cdots + Ax_{in}&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Question도 마찬가지로 Embedding matrix $B$를 곱하여 각각의 단어를 Embedding Vectors로 변환하고 이를 모두 더하여 Internal state $u$를 구한다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;u = \sum_{j} Bx_{ij} = Bx_{i1} + Bx_{i2} + \cdots + Bx_{in}&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;이후 Context와 Question의 유사성(match)를 구하기 위해 inner product를 시행한 후, Softmax Function으로 출력해준다. 이러한 결과로 input에 대한 확률을 도출 해낼 수 있다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;p_i = Softmax(u^Tm_i)&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉 $p_i$가 높을 수록 높은 유사성을 띈다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 통해서 &lt;strong&gt;Input Memory&lt;/strong&gt; 에는 Context 문장들(${x_i}$)과 질문($q$)의 축약된 정보가 들어가게 된다.&lt;/p&gt;

&lt;h3 id=&quot;output-memory&quot;&gt;Output Memory&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;모든 Context 문장들 ${x_i}$ 의 각각의 단어에  다시 Embedding matrix C를 곱하고 더하여 $c_i$로 변환한다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;c_i = \sum_{j} Cx_{ij} = Cx_{i1} + Cx_{i2} + \cdots + Cx_{in}&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;이는 출력으로 나오는 Response vector 인$o$ 를 구하기 위해서 인데, $o$는 아래와 같이 Input Memory에서 나오는 유사성(match, $p_i$)와 가중평균합을 진행한다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;o = \sum_{i} p_ic_i&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;final-prediction&quot;&gt;Final Prediction&lt;/h3&gt;
&lt;p&gt;output $o$와 질문으로부터 추출한 Internal state $u$에 가중치값 $W$를 곱하여 더한뒤에 Softmax Function을 적용하여 답 $\hat{a}$을 추론한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{a} = Softmax(W(o+u))&lt;/script&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;weight-updating&quot;&gt;Weight Updating&lt;/h3&gt;
&lt;p&gt;Loss Function은 standard cross-entropy loss를 사용하여 예측치 $\hat{a}$ 와 정답인 true 값 $a$ 간의 오차를 최소화해서 학습 시킨다.&lt;/p&gt;

&lt;p&gt;Input에서 Output까지 함수들은 무한정미분가능(function is smooth)하기 때문에, 손쉽게 Gradient와 back-propagate을 진행할 수 있다.&lt;/p&gt;

&lt;p&gt;업데이트 되는 weight Matrix는 $A$, $B$, $C$ 그리고 $W$다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;b-multiple-layers&quot;&gt;B. Multiple layers&lt;/h2&gt;

&lt;p&gt;위와 같은 Final Prediction 전 단계까지를 1 hop라고 규정하며, Multiple layers $K$ hops까지 확장 시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫번째, k번째 layer에서 나온 output으로 나온 $o^k$과 input $u^k$ 는 합쳐져서 새로운 input $u^{k+1}$ 가 되어서 k + 1 layer로 들어가게 된다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;u^{k+1} = u^k + o^k&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;각 layer마다 input에 embed로 사용된 embedding matrices $A^k$ 와 $C^k$ 가 존재한다. 그러나 이들은 쉽게 트레이닝하고, parameter 갯수를 줄이기 위해서 제약이 존재한다.&lt;/li&gt;
  &lt;li&gt;Network의 마지막 부분에서만 W를 곱해서 Softmax 로 출력한다.
    &lt;blockquote&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{a} = Softmax(Wu^{K+1}) = Softmax(W(o^K + u^K))&lt;/script&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;두 가지 가중치 버젼&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Adjacent:
    &lt;blockquote&gt;
      &lt;p&gt;$k_{th}$ output layer embedding matrix가 다음 input layer의 embedding matrix가 된다. 예를 들면, $A^{k+1} = C^k$. 또한, 두 가지 제약 조건을 추가했는데, (a) answer prediction matrix가 최종 output embedding과 같고 ($W^T = C^K)$, (b) question embedding 과 첫번째 layer의 input embedding과 같게 했다($B = A^1$).&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Layer-wise (RNN - like):
    &lt;blockquote&gt;
      &lt;p&gt;Input 과 Output embedding들이 layer마다 다 같다. 예를 들면, $A^1 = A^2 = \cdots = A^K$ 과 $C^1 = C^2 = \cdots = C^K$ 같은 것들. 또한, hops간 u를 업데이트하기위한 linear mapping $H$ 를 추가하는 것이 도움이 된다는 것을 알아냈다. $u^{k+1} = Hu^k + o^k$.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;층별로 가중치를 묶는 두 번째 방법은, tranditional 한 RNN 방식으로 생각할 수가 있다. Internal output($u$)을 내보내는 것은 memory에 해당하고, external outputs($\hat{a}$)는 라벨을 예측하는 것과 같다. RNN 관점에서 보면, $u$, $u^{k+1}$ 은 hidden state고, 모델은 $A$ 를 사용하여internal output $p$ 를 생성한다. 모델은 $C$ 를 사용해서 $p$ 의 정보를 흡수하고, hidden state를 업데이트면서 이런 식으로 계속 진행한다. 여기서 표준 RNN과 다르게 output들을 $K$ hops 동안 계속 메모리에 저장하고, sampling하는 대신에 soft하게 둔다. 그렇게 하여 답변이 “진짜 세상”에 나오기 전에 여러번 계산을 거치게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;c-synthetic-question-and-answering-experiments&quot;&gt;C. Synthetic Question and Answering Experiments&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;예시1:
    &lt;blockquote&gt;
      &lt;p&gt;Sam walks into the kitchen.&lt;/p&gt;

      &lt;p&gt;Sam picks up an apple.&lt;/p&gt;

      &lt;p&gt;Sam walks into the bedroom.&lt;/p&gt;

      &lt;p&gt;Sam drops the apple.&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #7d7ee8&quot;&gt;Q: Where is the apple?&lt;/span&gt;&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #e87d7d&quot;&gt;A. Bedroom&lt;/span&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;예시2:
    &lt;blockquote&gt;
      &lt;p&gt;Brian is a lion.&lt;/p&gt;

      &lt;p&gt;Julius is white.&lt;/p&gt;

      &lt;p&gt;Julius is a lion.&lt;/p&gt;

      &lt;p&gt;Bernhard is green.&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #7d7ee8&quot;&gt;Q: What color is Brian?&lt;/span&gt;&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #e87d7d&quot;&gt;A. White&lt;/span&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;예시3:
    &lt;blockquote&gt;
      &lt;p&gt;Mary journeyed to the den.&lt;/p&gt;

      &lt;p&gt;Mary went back to the kitchen.&lt;/p&gt;

      &lt;p&gt;John journeyed to the bedroom.&lt;/p&gt;

      &lt;p&gt;Mary discarded the milk.&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #7d7ee8&quot;&gt;Q: Where was the milk before the den?&lt;/span&gt;&lt;/p&gt;

      &lt;p&gt;&lt;span style=&quot;color: #e87d7d&quot;&gt;A. Hallway&lt;/span&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예시에도 보듯이 문장의 일부만 답변의 정답정보를 가지고 있다. 이를 support subset이라고 하며, training 할때 support subset을 명시한다. 그러나 실제 테스트할 때는 이 support subset이 표시되지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;model-details&quot;&gt;Model details&lt;/h3&gt;
&lt;p&gt;$K=3$ hops이고 weight sharing(Layer-wise) 모델을 쓸 것이다.  모든 output lists(답변에 여러 단어가 있는 경우)에 대하여 단어별로 분리하여 가능성을 나타낸다.&lt;/p&gt;

&lt;h4 id=&quot;sentence-representaion&quot;&gt;Sentence Representaion:&lt;/h4&gt;
&lt;p&gt;문장들을 표현할 때 두 가지 방법을 쓰기로 한다. 첫번째로는 BoW가 하나의 문장을 표현하는 것인데, 이 방법은 문장에서 단어의 순서(the order of the words in sentence)라는 특징을 잡을 수가 없다. 따라서 두 번째 방법으로, 문장에서 단어의 순서(the position of words)를 인코딩 한다. $m_i = \sum_{j} l_j \cdot Ax_{ij}$ 여기서 $l_j$ 연산은 element-wise multiplication이다. 또한, $l_j$ 는 $l_{kj} = (1-j/J) - (k/d)(1-2j/J)$, J는 문장에 있는 단어 갯수인 column vector 구조를 가지고 있다. 이것을 $PE$ (position encoding)이라고 하며, 이는 단어의 순서가 얼만큼 문장$m_i$에 영향을 주는지 알려준다. 나머지 question, memory inputs 그리고 memory outputs에서도 두 번째 방법으로 문장을 표현할 것이다.&lt;/p&gt;

&lt;h4 id=&quot;temporal-encoding&quot;&gt;Temporal Encoding:&lt;/h4&gt;
&lt;p&gt;많은 QA tasks에서는 temporal context라는 개념이 필요한데, 예를 들어 첫 번째 예시에서 Sam이 kitchen에 간 다음에 bedroom에 들어간 것을 알 수 있다. 이것을 모델에 적용하려면, memory vector를 약간 변형시킨다. $m_i = \sum_{j} Ax_{ij} + T_A(i)$, 여기서 $T_A(i)$ 는 일시적인 정보를 저장할 특별한 행렬 $T_A$ 의 i 번째 행이다. Ouput embedding할 때도 마찬가지로 해준다. $c_i = \sum_{j} Cx_{ij} + T_C(i)$. $T_A$ 와 $T_C$ 둘다 training 할 때 갱신한다. 그리고 A 와 C 랑 마찬가지로 제약 또한 같이 공유한다. 여기서 주의할 점은 문장들이 역순으로 인덱싱되어있다.  문장이 질문으로부터 상대적인 거리를 반영한다, 즉 $x_1$ 은 이야기의 마지막 문장이 된다.&lt;/p&gt;

&lt;h4 id=&quot;learning-time-invariance-by-injecting-random-noise&quot;&gt;Learning time invariance by injecting random noise:&lt;/h4&gt;
&lt;p&gt;$T_A$ 를 정규화 시킬때 더미 변수를 넣는 것이 도움이 된다. 즉, 트레이닝할 때는 랜덤으로 10%의 빈 메모리를 스토리에 넣는 것이다. 여기서 이를 Random Noise (RN)라고 한다&lt;/p&gt;

&lt;h3 id=&quot;training-details&quot;&gt;Training Details&lt;/h3&gt;
&lt;p&gt;bAbI training set중 10%는 Validation용으로 쓴다. 이는 optimal model architecture 과 hyperparameters를 선택하기 위해서다. Learning rate $\eta$는 0.01로 설정하고, 100번째 epoch가 될때 까지, 매 25번째 epochs 마다, $\eta$ 를 2로 나눠준다. Momentum 이나 weight decay는 사용되지 않았다. 가중치들은 $\mu = 0$, $\sigma = 0.1$ 인 가우시안 정규분포로 초기값을 설정했다. 모든 training에 사용된 batch size는 32 이며, gradients는 L2로 정규화해서 40이 넘으면 어떤 스칼라를 나눠서 norm을 40으로 만들어준다.&lt;/p&gt;

&lt;p&gt;어떤 모델에서는 처음시작에 softmax를 안쓰다가 (linear하게 만드는 것) 나중에 최종 예측시에 softmax를 썼다. 그러다 validation loss가 더 이상 떨어지지 않을 때, 다시 softmax 층이 다시 입력이 되서 트레이닝을 한다. 이를 Linear Start (LS) training이라고 하며, 이때 초기 learning rate 를 $\eta = 0.005$ 로 설정한다.&lt;/p&gt;

&lt;h3 id=&quot;baselines&quot;&gt;Baselines&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MemNN: strongly supervised, softmax대신 max operation사용&lt;/li&gt;
  &lt;li&gt;MemNN-WSH: weakly supervised, 트레이닝시 supporting sentence labels를 안씀&lt;/li&gt;
  &lt;li&gt;LSTM: weakly supervised&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;result&quot;&gt;Result&lt;/h3&gt;
&lt;p&gt;모델 선택을 다양하게 했다.&lt;/p&gt;

&lt;p&gt;1) BoW vs Position Encoding&lt;/p&gt;

&lt;p&gt;2) 20 tasks를 독립적으로 트레이닝공유($d = 20$) vs joint 트레이닝 ($d = 50$)&lt;/p&gt;

&lt;p&gt;3) Linear Start Training(Softmax처음에 없엔 것) vs Softmax가 처음부터 있는 것&lt;/p&gt;

&lt;p&gt;4) hops를 1 ~ 3까지 설정&lt;/p&gt;

&lt;p&gt;결과는 논문 참조. 퍼포먼스는 supervised models이 제일 좋게 나왔으나, MemN2N with position encoding + linear start + random noise, jointly trained 도 근접하게 나옴&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;d&quot;&gt;D.참고문헌&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1503.08895&quot;&gt;End-To-End Memory Networks: Sainbayar Sukhbaatar, Arthur Szlam, Jason Weston, Rob Fergus&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Aug 2017 22:09:05 +0900</pubDate>
        <link>http://simonjisu.github.io/datascience/2017/08/04/E2EMN.html</link>
        <guid isPermaLink="true">http://simonjisu.github.io/datascience/2017/08/04/E2EMN.html</guid>
        
        
        <category>DataScience</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;h2 id=&quot;adding-new-posts&quot;&gt;Adding New Posts&lt;/h2&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;h3 id=&quot;tags-and-categories&quot;&gt;Tags and Categories&lt;/h3&gt;

&lt;p&gt;If you list one or more categories or tags in the front matter of your post, they will be included with the post on the page as links. Clicking the link will bring you to an auto-generated archive page for the category or tag, created using the &lt;a href=&quot;https://github.com/jekyll/jekyll-archives&quot;&gt;jekyll-archive&lt;/a&gt; gem.&lt;/p&gt;

&lt;h3 id=&quot;cover-images&quot;&gt;Cover Images&lt;/h3&gt;

&lt;p&gt;To add a cover image to your post, set the “cover” property in the front matter with the relative URL of the image (i.e. &lt;code&gt;cover: &quot;/assets/cover_image.jpg&quot;&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;code-snippets&quot;&gt;Code Snippets&lt;/h3&gt;

&lt;p&gt;You can use &lt;a href=&quot;https://highlightjs.org/&quot;&gt;highlight.js&lt;/a&gt; to add syntax highlight code snippets:&lt;/p&gt;

&lt;p&gt;Use the &lt;a href=&quot;https://github.com/Shopify/liquid/wiki/Liquid-for-Designers&quot;&gt;Liquid&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;language&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; tag to add syntax highlighting to code snippets.&lt;/p&gt;

&lt;p&gt;For instance, this template…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;{% highlight javascript %}    
function demo(string, times) {    
  for (var i = 0; i &lt;span class=&quot;nt&quot;&gt;&amp;lt; times&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;    
    &lt;span class=&quot;na&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;    
  &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;    
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;    
&lt;span class=&quot;na&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;world&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;!&quot;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{%&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;endhighlight&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;…will come out looking like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello, world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Syntax highlighting is done using &lt;a href=&quot;https://highlightjs.org/&quot;&gt;highlight.js&lt;/a&gt;. You can change the active theme in &lt;a href=&quot;https://github.com/bencentra/centrarium/blob/2dcd73d09e104c3798202b0e14c1db9fa6e77bc7/_includes/head.html#L15&quot;&gt;head.html&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;images&quot;&gt;Images&lt;/h3&gt;

&lt;p&gt;Lightbox has been enabled for images. To create the link that’ll launch the lightbox, add &lt;code&gt;data-lightbox&lt;/code&gt; and &lt;code&gt;data-title&lt;/code&gt; attributes to an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag around your &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag. The result is:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;//bencentra.com/assets/images/falcon9_large.jpg&quot; data-lightbox=&quot;falcon9-large&quot; data-title=&quot;Check out the Falcon 9 from SpaceX&quot;&gt;
  &lt;img src=&quot;//bencentra.com/assets/images/falcon9_small.jpg&quot; title=&quot;Check out the Falcon 9 from SpaceX&quot; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For more information, check out the &lt;a href=&quot;http://lokeshdhakar.com/projects/lightbox2/&quot;&gt;Lightbox&lt;/a&gt; website.&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 18 Apr 2015 17:43:59 +0900</pubDate>
        <link>http://simonjisu.github.io/jekyll/2015/04/18/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://simonjisu.github.io/jekyll/2015/04/18/welcome-to-jekyll.html</guid>
        
        <category>jekyll</category>
        
        <category>welcome</category>
        
        
        <category>Jekyll</category>
        
      </item>
    
  </channel>
</rss>
